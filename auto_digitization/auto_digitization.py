# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AutoDigitization
                                 A QGIS plugin
 This Plugin automatically digitizes the reconstruction plans
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-08-21
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Metehan Ergen / Hacettepe University - Politecnico di Milano
        email                : metehan.ergenn@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon, QDoubleValidator
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from qgis.core import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .auto_digitization_dialog import AutoDigitizationDialog
import os.path
from osgeo import ogr, gdal
import os
from sklearn.cluster import DBSCAN
import numpy as np
from numpy import unique
import re

class AutoDigitization:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'AutoDigitization_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Automatic Digitization')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('AutoDigitization', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/auto_digitization/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Automatically Digitize'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&Automatic Digitization'),
                action)
            self.iface.removeToolBarIcon(action)
    def controlEnabled(self, checked):

        if checked == True:
            self.dlg.mMapLayerComboBox_3.setEnabled(True)
        else:
            self.dlg.mMapLayerComboBox_3.setEnabled(False)
            
    def EmsalControlEnabled(self,checked):
        if checked == True:
            self.dlg.lineEdit_MaxDistance.setEnabled(False)
        else:
            self.dlg.lineEdit_MaxDistance.setEnabled(True)
            
    def process_all(self,checked):
        if checked == True:
            self.dlg.mMapLayerComboBox.setEnabled(False)
        else:
            self.dlg.mMapLayerComboBox.setEnabled(True)

    def controlImar(self,polyLayer,PointLayer,ControlPolygon,parameters):
        isBBOX = 1
        polyLayer.startEditing()

        maxLength = parameters[0]
        Buffer = parameters[1]
        PointLayerField =  parameters[2]
        minCluster = parameters[3]

        points = [feat for feat in PointLayer.getFeatures()]
        polygons = [feat for feat in polyLayer.getFeatures()]
        polygon_tic = [feat for feat in ControlPolygon.getFeatures()]
  
        
        index = QgsSpatialIndex() # this spatial index contains all the features of the point layer
        for point in points:
            index.insertFeature(point)


        for polygon in polygons:
            
            
            #inAttr = polygon.attributes() # Input attributes
            poly_geom = polygon.geometry() #Input geometry
            #geoms = QgsGeometry.fromWkt('GEOMETRYCOLLECTION()')
            if isBBOX == 1:
                box = poly_geom.boundingBox()   # Check whether bbox is gonna be used or not 
                box.grow(10)
                bbox = QgsGeometry.fromRect(box)
                idsList = index.intersects(box)
            else:
                bbox = poly_geom
                idsList = index.intersects(bbox.boundingBox())
                  
                
            """
            if poly_geom:
                err = poly_geom.validateGeometry()
                if not err:
                    geoms = geoms.combine(poly_geom)
                else:
                    print('%d geometry errors detected (feature %d)' % (len(err), feature.id())) 
            """
            #engine = QgsGeometry.createGeometryEngine(abst)
            #engine.prepareGeometry()
            #idsList = index.intersects(poly_geom.boundingBox()) ### !!! NOT SURE !!! <<<££££#>£#>£
            for poly3 in polygon_tic:
                if poly_geom.intersects(poly3.geometry()):
                
                    if int(polygon["ER_COUNT"]) < int(polygon["cluster"]):
                 
                        if len(idsList) > 0:
                            req = QgsFeatureRequest().setFilterFids(idsList)
                            
                            inPointList = []
                            PointGeomList = []
                            for fit in PointLayer.getFeatures(req):
                                geom = fit.geometry()
                                if bbox.contains(geom):
                                        inPointList.append(fit) ###
                                        PointGeomList.append([geom.get().x(),geom.get().y()])
                            try:
                                clustering = DBSCAN(eps=maxLength, min_samples=minCluster).fit(PointGeomList) # DBSCAN Clustering Algorithm
                            except:
                                print("cluster error at: "+str(polygon.id()))
                                continue
                            
                           
                            nizam = []
                            kat = []    # Creating empty lists for checking multiple IMAR clusters in same polygon
                            yanbahce = []
                            onbahce = []
                            error = []
                            clusterAmount = 0
                            for i in unique(clustering.labels_):
                                validator = 0
                                
                                if i == -1:
                                    continue
                                tempList = []
                                tempCoordList = []
                                for j in range(len(inPointList)):
                                    if i == clustering.labels_[j]:
                                        if not poly_geom.contains(inPointList[j].geometry()):
                                            continue
                                        if poly3.geometry().contains(inPointList[j].geometry()):
                                            continue
                                        
                                        else:
                                            tempCoordList.append(PointGeomList[j])
                                            tempList.append(inPointList[j])
                                    
                                    
                                if not len(tempList) < 2 and validator == 0:
                                 
                                    clusterAmount += 1
                                        
                                    ds = np.array(tempCoordList)
                                    min_index_col = np.argmin(ds[:,0], axis=0)
                                    max_index_col = np.argmax(ds[:,0], axis=0)
                                   
                                    if tempList[min_index_col].geometry().get().y() - tempList[max_index_col].geometry().get().y() > 1:
                                        continue
                                    
                                    try:
                                        int(tempList[min_index_col][PointLayerField])
                                        continue
                                    except:
                                        
                                        if len(nizam) == 0:
                                            polygon["NIZAM"] = tempList[min_index_col][PointLayerField]
                                            nizam.append(tempList[min_index_col][PointLayerField])
                                        elif not str(tempList[min_index_col][PointLayerField]) in nizam:
                                            polygon["NIZAM"] = str(polygon["NIZAM"])+"-"+str(tempList[min_index_col][PointLayerField])
                                            nizam.append(tempList[min_index_col][PointLayerField])
                                        
                                    #if polygon["KAT_ADETI"] < tempList[max_index_col][PointLayerField]:
                                    if len(kat) == 0:
                                        polygon["KAT_ADETI"] = tempList[max_index_col][PointLayerField]
                                        kat.append(tempList[max_index_col][PointLayerField])
                                        
                                        
                                    elif not str(tempList[max_index_col][PointLayerField]) in kat:
                                        polygon["KAT_ADETI"] = str(polygon["KAT_ADETI"])+"-"+str(tempList[max_index_col][PointLayerField])
                                        kat.append(tempList[max_index_col][PointLayerField])
                                        
                                        
                                    if len(tempList) == 2:
                                        continue
                                    #centroid = [(nizam[0]+kat[0])/2,(nizam[1]+kat[1])/2]
                                    centroid = tempList[min_index_col].geometry().get().y()
                                    for k in range(len(tempList)):
                                        if abs(centroid-tempList[k].geometry().get().y()) > 0.01:
                                            if centroid > tempList[k].geometry().get().y():
                                                #if polygon["YANBAHCE"] < tempList[k][PointLayerField]:
                                                if len(yanbahce) == 0:
                                                    polygon["YANBAHCE"] = tempList[k][PointLayerField]
                                                    yanbahce.append(tempList[k][PointLayerField])
                                                elif not str(tempList[k][PointLayerField]) in yanbahce:
                                                    polygon["YANBAHCE"] = str(polygon["YANBAHCE"])+"-"+str(tempList[k][PointLayerField])
                                                    yanbahce.append(tempList[k][PointLayerField])
                                            elif centroid < tempList[k].geometry().get().y():
                                                #if polygon["ONBAHCE"] < tempList[k][PointLayerField]:
                                                if len(onbahce) == 0:
                                                    polygon["ONBAHCE"] = tempList[k][PointLayerField]
                                                    onbahce.append(tempList[k][PointLayerField])
                                                elif not str(tempList[k][PointLayerField]) in onbahce:
                                                    polygon["ONBAHCE"] = str(polygon["ONBAHCE"])+"-"+str(tempList[k][PointLayerField])
                                                    onbahce.append(tempList[k][PointLayerField])
                    else:
                        
                        print(polygon.id())
                        
                    
            #print(type(polygon["ER_COUNT"]))
            polyLayer.updateFeature(polygon)
        polyLayer.commitChanges()              
            
    def emsal(self,polyLayer,PointLayer,parameters):
        
        maxLength = parameters[0]
        Buffer = parameters[1]
        PointLayerField =  parameters[2]
        
        polyLayer.startEditing()
        
        points = [feat for feat in PointLayer.getFeatures()]
        polygons = [feat for feat in polyLayer.getFeatures()]

        index = QgsSpatialIndex() # this spatial index contains all the features of the point layer
        for point in points:
            index.insertFeature(point)


        for polygon in polygons:
            
            #inAttr = polygon.attributes() # Input attributes
            poly_geom = polygon.geometry() #Input geometry
            #geoms = QgsGeometry.fromWkt('GEOMETRYCOLLECTION()')
            """
            if poly_geom:
                err = poly_geom.validateGeometry()
                if not err:
                    geoms = geoms.combine(poly_geom)
                else:
                    print('%d geometry errors detected (feature %d)' % (len(err), feature.id())) 
            """
            #engine = QgsGeometry.createGeometryEngine(abst)
            #engine.prepareGeometry()
            idsList = index.intersects(poly_geom.boundingBox())
            
            if len(idsList) > 0:
                req = QgsFeatureRequest().setFilterFids(idsList)
                
                inPointList = []
                PointGeomList = []
                for fit in PointLayer.getFeatures(req):
                    geom = fit.geometry()
                    if poly_geom.contains(geom):
                            inPointList.append(fit) ###
                            PointGeomList.append([geom.get().x(),geom.get().y()])
                            
                for i in range(len(inPointList)):
                    if "Hmax" in inPointList[i][PointLayerField]:
                        flt = re.findall("\d+\.\d+", inPointList[i][PointLayerField])
                        if not flt == []:
                            polygon["Y_MAX"] = float(flt[0]) 
                        else:
                            hmax_val = (re.findall(r'=(\w+)', inPointList[i][PointLayerField]) or None,)[0]
                            polygon["Y_MAX"] = hmax_val[0]
                            continue
                        
                    elif "E=" in inPointList[i][PointLayerField] or "E:" in inPointList[i][PointLayerField]:
                        flt = re.findall("\d+\.\d+", inPointList[i][PointLayerField])
                        if not flt == []:
                            polygon["EMSAL"] = float(flt[0]) 
                        else:
                            print("emsal error at: "+str(polygon.id()))
                            
                    elif "KATLI" in inPointList[i][PointLayerField]:
                        intG = re.findall(r'\d+', inPointList[i][PointLayerField])
                        if not intG == []:
                            polygon["KAT_ADETI"] = float(intG[0]) 
                        else:
                            print("Y_MAX error at: "+str(polygon.id()))
                            
                    elif "(En" in inPointList[i][PointLayerField] or "Yen" in inPointList[i][PointLayerField]:
                        
                        intG = re.findall(r'\d+', inPointList[i][PointLayerField])
                        if not intG == []:
                            polygon["KAT_ADETI"] = int(intG[0])
                        else:
                            print("'Kat' error at"+str(polygon.id()))
                            
                    elif "TAKS" in inPointList[i][PointLayerField]:
                        flt = re.findall("\d+\.\d+", inPointList[i][PointLayerField])
                        if not flt == []:
                            polygon["TAKS"] = float(flt[0]) 
                        else:
                            print("TAKS error at: "+str(polygon.id()))
                            
                    else:
                        print("No data found at :"+ str(polygon.id()))
                polyLayer.updateFeature(polygon)        
        polyLayer.commitChanges()          

    def taks_kaks(self,polyLayer,PointLayer,parameters):
        maxLength = parameters[0]
        Buffer = parameters[1]
        PointLayerField =  parameters[2]
        
        polyLayer.startEditing()
        points = [feat for feat in PointLayer.getFeatures()]
        polygons = [feat for feat in polyLayer.getFeatures()]

        index = QgsSpatialIndex() # this spatial index contains all the features of the point layer
        for point in points:
            index.insertFeature(point)


        for polygon in polygons:
            polygon["TAKS"] = NULL
            polygon["KAKS"] = NULL
           
            
            poly_geom = polygon.geometry() #Input geometry
          
            
            idsList = index.intersects(poly_geom.boundingBox())
            
            if len(idsList) > 0:
                req = QgsFeatureRequest().setFilterFids(idsList)
                
                inPointList = []
                PointGeomList = []

                repeat = 0
                for fit in PointLayer.getFeatures(req):
                    
                    if not fit[PointLayerField].isdigit() == True:
                        try:                                            # Check the point value is float or not
                            float(fit[PointLayerField])
                            
                            geom = fit.geometry()
                            if poly_geom.contains(geom):
                                    inPointList.append(fit)             
                                    PointGeomList.append([geom.get().x(),geom.get().y()])
                        except:
                            continue
                    else:
                        continue
                    
                try:
                    clustering = DBSCAN(eps=maxLength, min_samples=2).fit(PointGeomList)
                except:
                    print("Cluster Error at: "+str(polygon.id()))
                    continue
                    
                for i in unique(clustering.labels_):
                    if i == -1:
                            continue
                    tempList = []
                    tempCoordList = []
                    for j in range(len(inPointList)):
                        if i == clustering.labels_[j]:
                            tempCoordList.append(PointGeomList[j])
                            tempList.append(inPointList[j])
                           
                    if not len(tempList) < 2:
                        ds = np.array(tempCoordList)
                        min_index_col = np.argmin(ds[:,1], axis=0)
                        max_index_col = np.argmax(ds[:,1], axis=0)
                        polygon["TAKS"] = tempList[max_index_col][PointLayerField] 
                        polygon["KAKS"] = tempList[min_index_col][PointLayerField]   
               
            polyLayer.updateFeature(polygon)                        
        polyLayer.commitChanges()       
       
    def imar_automation(self,polyLayer,PointLayer,parameters):
        
        polyLayer.startEditing()
        maxLength = parameters[0]
        Buffer = parameters[1]
        PointLayerField =  parameters[2]
        minCluster = parameters[3]
        
        isBBOX = 1
        points = [feat for feat in PointLayer.getFeatures()]
        polygons = [feat for feat in polyLayer.getFeatures()]
        
        
        index = QgsSpatialIndex() # this spatial index contains all the features of the point layer
        for point in points:
            index.insertFeature(point)


        for polygon in polygons:
    
            attributeList = ["NIZAM","ONBAHCE","KAT_ADETI","YANBAHCE","error","cluster","ER_COUNT"]
            
            for i in attributeList:
                polygon[i] = NULL # Resetting the attributes before start
                
            #inAttr = polygon.attributes() # Input attributes
            poly_geom = polygon.geometry() #Input geometry
            #geoms = QgsGeometry.fromWkt('GEOMETRYCOLLECTION()')
            if isBBOX == 1:
                box = poly_geom.boundingBox()   # Check whether bbox is gonna be used or not 
                box.grow(maxLength)
                bbox = QgsGeometry.fromRect(box)
                idsList = index.intersects(box)
            else:
                bbox = poly_geom
                idsList = index.intersects(bbox.boundingBox())
                  
                
            """
            if poly_geom:
                err = poly_geom.validateGeometry()
                if not err:
                    geoms = geoms.combine(poly_geom)
                else:
                    print('%d geometry errors detected (feature %d)' % (len(err), feature.id())) 
            """
            #engine = QgsGeometry.createGeometryEngine(abst)
            #engine.prepareGeometry()
            #idsList = index.intersects(poly_geom.boundingBox()) ### !!! NOT SURE !!! <<<££££#>£#>£
            
            if len(idsList) > 0:
                req = QgsFeatureRequest().setFilterFids(idsList)
                
                inPointList = []
                PointGeomList = []
                for fit in PointLayer.getFeatures(req):
                    geom = fit.geometry()
                    if bbox.contains(geom):
                            inPointList.append(fit) ###
                            PointGeomList.append([geom.get().x(),geom.get().y()])
                try:
                    clustering = DBSCAN(eps=maxLength, min_samples=minCluster).fit(PointGeomList) # DBSCAN Clustering Algorithm
                except:
                    print("cluster error at: "+str(polygon.id()))
                    continue
                
                nizam = []
                kat = []    # Creating empty lists for checking multiple IMAR clusters in same polygon
                yanbahce = []
                onbahce = []
                error = []
                clusterAmount = 0
                errorCounter = 0
                for i in unique(clustering.labels_):
                    validation = 0
                    
                    if i == -1:
                        continue
                        
                    
                    tempList = []
                    tempCoordList = []
                    stCount = 0
                    for j in range(len(inPointList)):
                        if i == clustering.labels_[j]:
                            tempCoordList.append(PointGeomList[j])
                            if poly_geom.contains(inPointList[j].geometry()):
                                validation += 1
                            try:
                                tempList.append(int(inPointList[j]))
                            except:
                                tempList.append(inPointList[j])
                   
                    if validation >0 and validation < len(tempList): # ERRORS
                        errorCounter += 1
                        if error == []:
                            polygon["error"] = str(validation)
                            error.append(str(validation))
                        else:
                            polygon["error"] = str(polygon["error"])+"-"+str(validation)
                            error.append(str(validation))

                    stCount = 0
                    for m in tempList:
                        try:
                            int(m[PointLayerField])
                            
                            
                        except:
                            print(m[PointLayerField])
                            stCount += 1
                            
                        
                    if not len(tempList) < 2 and validation > 0 and stCount == 1: # Even if there is one point inside it is being considered
                        clusterAmount += 1
                            
                        ds = np.array(tempCoordList)
                        min_index_col = np.argmin(ds[:,0], axis=0)
                        max_index_col = np.argmax(ds[:,0], axis=0)
                        if tempList[min_index_col].geometry().get().y() - tempList[max_index_col].geometry().get().y() > 1:
                            continue
                        
                        try:
                            int(tempList[min_index_col][PointLayerField])
                            continue
                        except:
                            if len(nizam) == 0:
                                polygon["NIZAM"] = tempList[min_index_col][PointLayerField]
                                nizam.append(tempList[min_index_col][PointLayerField])
                            elif not str(tempList[min_index_col][PointLayerField]) in nizam:
                                polygon["NIZAM"] = str(polygon["NIZAM"])+"-"+str(tempList[min_index_col][PointLayerField])
                                nizam.append(tempList[min_index_col][PointLayerField])
                            
                        #if polygon["KAT_ADETI"] < tempList[max_index_col][PointLayerField]:
                                
                        if len(kat) == 0:
                            polygon["KAT_ADETI"] = tempList[max_index_col][PointLayerField]
                            kat.append(tempList[max_index_col][PointLayerField])
                            
                            
                        elif not str(tempList[max_index_col][PointLayerField]) in kat:
                            polygon["KAT_ADETI"] = str(polygon["KAT_ADETI"])+"-"+str(tempList[max_index_col][PointLayerField])
                            kat.append(tempList[max_index_col][PointLayerField])

                        
                            
                        if len(tempList) == 2:
                            continue

                        
                        #centroid = [(nizam[0]+kat[0])/2,(nizam[1]+kat[1])/2]
                        centroid = tempList[min_index_col].geometry().get().y()
                        for k in range(len(tempList)):
                            if abs(centroid-tempList[k].geometry().get().y()) > maxLength/4:
                                if centroid > tempList[k].geometry().get().y():
                                    if len(yanbahce) == 0:
                                        polygon["YANBAHCE"] = tempList[k][PointLayerField]
                                        yanbahce.append(tempList[k][PointLayerField])
                                    elif not str(tempList[k][PointLayerField]) in yanbahce:
                                        polygon["YANBAHCE"] = str(polygon["YANBAHCE"])+"-"+str(tempList[k][PointLayerField])
                                        yanbahce.append(tempList[k][PointLayerField])
                                elif centroid < tempList[k].geometry().get().y():
                                    if len(onbahce) == 0:
                                        polygon["ONBAHCE"] = tempList[k][PointLayerField]
                                        onbahce.append(tempList[k][PointLayerField])
                                    elif not str(tempList[k][PointLayerField]) in onbahce:
                                        polygon["ONBAHCE"] = str(polygon["ONBAHCE"])+"-"+str(tempList[k][PointLayerField])
                                        onbahce.append(tempList[k][PointLayerField])
                polygon["cluster"] = clusterAmount        
                polygon["ER_COUNT"] = errorCounter
            else:
                polygon["error"] = "empty" 
                polygon["cluster"] = 0
                polygon["ER_COUNT"] = 0

            polyLayer.updateFeature(polygon)
        polyLayer.commitChanges()                           
            
    def clear_ui(self):
        """Clearing the UI for new operations"""
        self.dlg.mMapLayerComboBox.clear()
        self.dlg.mMapLayerComboBox_2.clear()
        self.dlg.mMapLayerComboBox_3.clear()
        self.dlg.spinBox.clear()
        self.dlg.lineEdit_MaxDistance.clear()
        self.dlg.lineEdit_Buffer.clear()
        
    def clear_fields(self):
        """Clearing the fields when layers are changed"""
        self.dlg.mFieldComboBox_2.clear()



    def load_comboBox(self):
        """Load the fields into combobox when layers are changed"""
        pointLayer_shp = []
        polygonLayer_shp = []
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        if len(layers) != 0:  # checklayers exist in the project
            for layer in layers:
                if hasattr(layer, "dataProvider"):  # to not consider Openlayers basemaps in the layer list
                    myfilepath = layer.dataProvider().dataSourceUri()  # directory including filename
                    (myDirectory, nameFile) = os.path.split(myfilepath)  # splitting into directory and filename
                    #if (".shp" in nameFile):
                    if layer.geometryType() == 0:
                        pointLayer_shp.append(layer)
                    elif layer.geometryType() == 2:
                        polygonLayer_shp.append(layer)
                        
        selectedPolygonLayerIndex = self.dlg.mMapLayerComboBox.currentIndex()
        selectedPointLayerIndex = self.dlg.mMapLayerComboBox_2.currentIndex()
        
        if selectedPointLayerIndex < 0 or selectedPointLayerIndex > len(pointLayer_shp):
            return
        try:
            selectedPointLayer = pointLayer_shp[selectedPointLayerIndex]
            selectedPolygonLayer = polygonLayer_shp[selectedPolygonLayerIndex]
        except:
            return

        fieldnamesPointLayer = [field.name() for field in selectedPointLayer.fields()]
        fieldnamesPolygonLayer = [field.name() for field in selectedPolygonLayer.fields()]

        self.clear_fields()
        self.dlg.mFieldComboBox_2.addItems(fieldnamesPointLayer)
       
        # gotta look at below !!!
        
    def error_msg(self,missingFields):
        """Message to report missing fields"""
        self.loadLayerList()
        missingStrings = ""
        for i in missingFields:
            missingStrings = str(missingStrings)+ str(i) +","
        
        QMessageBox.warning(self.dlg.show(), self.tr("AutomaticDigitizing:Warning"),
                            self.tr(str(missingStrings)+"Fields are missing"), QMessageBox.Ok)
    def error_msgIndex(self,errorText):
        """Message to report missing fields"""
        
        QMessageBox.warning(self.dlg.show(), self.tr("AutomaticDigitizing:Warning"),
                            self.tr(errorText), QMessageBox.Ok)
        
    def success_msg(self):
        """Message to report succesful process"""
        QMessageBox.information(self.dlg, self.tr("AutomaticDigitizing:Success"),
                                self.tr("Process is done successfuly."),QMessageBox.Ok)


    def loadLayerList(self):
        polygonLayersList = []
        polygonLayers_shp = []
        
        pointLayersList = []
        pointLayers_shp = []
        # Show the shapefiles in the ComboBox
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        if len(layers) != 0:  # checklayers exist in the project
            for layer in layers:
                if hasattr(layer, "dataProvider"):  # to not consider Openlayers basemaps in the layer list
                    myfilepath = layer.dataProvider().dataSourceUri()  # directory including filename
                    (myDirectory, nameFile) = os.path.split(myfilepath)  # splitting into directory and filename
                    #if (".shp" in nameFile):
                    if layer.geometryType() == 0:
                        pointLayersList.append(layer.name())
                        pointLayers_shp.append(layer)
                    elif layer.geometryType() == 2:
                        polygonLayersList.append(layer.name())
                        polygonLayers_shp.append(layer)
                        
            # Layer lists
            self.dlg.mMapLayerComboBox.addItems(polygonLayersList)
            self.dlg.mMapLayerComboBox_2.addItems(pointLayersList)
            self.dlg.mMapLayerComboBox_3.addItems(polygonLayersList)
            # Point and Polygon layer indexes
            selectedPolygonLayerIndex = self.dlg.mMapLayerComboBox.currentIndex()
            selectedPointLayerIndex = self.dlg.mMapLayerComboBox_2.currentIndex()
            # GOTTA LOOK AT BELOW !!!
            if selectedPointLayerIndex < 0 or selectedPointLayerIndex > len(pointLayers_shp):
                return

            # Selected layers
            selectedPolygonLayer = polygonLayers_shp[selectedPolygonLayerIndex]
            selectedPointLayer = pointLayers_shp[selectedPointLayerIndex]

            fieldnamesPointLayer = [field.name() for field in selectedPointLayer.fields()]
           
            self.clear_fields()
            self.dlg.mFieldComboBox_2.addItems(fieldnamesPointLayer)
            
            try:
                self.dlg.mMapLayerComboBox_2.activated.connect(lambda: self.load_comboBox())
                self.dlg.mMapLayerComboBox_2.currentIndexChanged.connect(lambda: self.load_comboBox())
                self.dlg.radioButton_CONTROL.toggled.connect(self.controlEnabled)
                self.dlg.radioButton_EMSAL.toggled.connect(self.EmsalControlEnabled)
                self.dlg.checkBox.toggled.connect(self.process_all)
            except:
                return False
            return [layers, polygonLayers_shp, pointLayers_shp, fieldnamesPointLayer]
        else: 
            return [layers, False]
        
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = AutoDigitizationDialog()
            validator = QDoubleValidator(0.0,99999.0,3)
            self.dlg.lineEdit_Buffer.setValidator(validator)
            self.dlg.lineEdit_MaxDistance.setValidator(validator)
            
            

        self.clear_ui()
        
        self.dlg.lineEdit_MaxDistance.setText("8.3")
        self.dlg.lineEdit_Buffer.setText("10")
        self.dlg.spinBox.setValue(2)
        
        layers, layers_shp, pointLayer_shp, fieldnamesPointLayer = self.loadLayerList()
        if len(layers) == 0:
            return

        # show the dialog
        self.dlg.show()
        self.load_comboBox()
        
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            selectedPolygonLayerIndex = self.dlg.mMapLayerComboBox.currentIndex()
            selectedPointLayerIndex = self.dlg.mMapLayerComboBox_2.currentIndex()
            selectedControlLayerIndex = self.dlg.mMapLayerComboBox_3.currentIndex()
            
            selectedAttributeIndex = self.dlg.mFieldComboBox_2.currentIndex()
            
            PointLayerField = fieldnamesPointLayer[selectedAttributeIndex]
            
            
            fieldNameList = ["NIZAM", "KAT_ADETI", "TAKS", "KAKS", "ONBAHCE", "YANBAHCE", "ARKABAHCE",  "EMSAL" ,"Y_MAX"]
            newFieldsList = ["error","cluster","ER_COUNT"]
            emsalFieldsList = ["EMSAL","Y_MAX","KAT_ADETI","TAKS"]
            taks_kaksFieldList = ["TAKS","KAKS"]
            # Missing Lines Error Check

            """
            missingFields = []
            for i in fieldNameList:
                if not i in layers_shp[selectedPolygonLayerIndex].fields().names():
                    missingFields.append(str(i))

                
            if len(missingFields) > 0:
                self.error_msg(missingFields)
                return
            """
            
            maxLength = float(self.dlg.lineEdit_MaxDistance.text())
            Buffer = float(self.dlg.lineEdit_Buffer.text())
            minCluster = int(self.dlg.spinBox.value())
            
            parameters = [maxLength,Buffer,PointLayerField,minCluster]

            if self.dlg.checkBox.isChecked():
                RunTime = len(layers_shp)
            else:
                RunTime = 1

            MissingFieldVal = False
          
            for i in range(RunTime):
                if RunTime == 1:
                        i = selectedPolygonLayerIndex
                    
                if self.dlg.radioButton_IMAR.isChecked(): # DIGITIZING: IMAR
                    polyDataProv =  layers_shp[i].dataProvider()       
                    for k in newFieldsList:
                        if not k in layers_shp[i].fields().names():
                            MissingFieldVal = True
                            if k == "error":
                                polyDataProv.addAttributes([QgsField(k,QVariant.String)])
                            else:
                                polyDataProv.addAttributes([QgsField(k,QVariant.Int)])

                    if MissingFieldVal == True:
                        layers_shp[i].updateFields()
                    self.imar_automation(layers_shp[i],pointLayer_shp[selectedPointLayerIndex],parameters)
                    
                elif self.dlg.radioButton_TAKS.isChecked(): # DIGITIZING: TAKS/KAKS
                    
                    polyDataProv =  layers_shp[i].dataProvider()       
                    for k in taks_kaksFieldList:
                        if not k in layers_shp[i].fields().names():
                            MissingFieldVal = True
                            polyDataProv.addAttributes([QgsField(k,QVariant.String)])

                    if MissingFieldVal == True:
                        layers_shp[i].updateFields()
                        
                    self.taks_kaks(layers_shp[i],pointLayer_shp[selectedPointLayerIndex],parameters)
                    
                elif self.dlg.radioButton_EMSAL.isChecked(): # DIGITIZING: EMSAL
                    
                    polyDataProv =  layers_shp[i].dataProvider()       
                    for k in emsalFieldsList:
                        if not k in layers_shp[i].fields().names():
                            MissingFieldVal = True
                            polyDataProv.addAttributes([QgsField(k,QVariant.String)])

                    if MissingFieldVal == True:
                        layers_shp[i].updateFields()
                        
                    self.emsal(layers_shp[i],pointLayer_shp[selectedPointLayerIndex],parameters)
                    
                elif self.dlg.radioButton_CONTROL.isChecked(): # DIGITIZING: CONTROL
                    if selectedControlLayerIndex == selectedPolygonLayerIndex:
                        self.error_msgIndex("Control Layer cannot be same with the Input Layer !")
                    
                        
                    else:
                        polyDataProv =  layers_shp[i].dataProvider()       
                        for k in newFieldsList:
                            if not k in layers_shp[i].fields().names():
                                MissingFieldVal = True
                                break

                        if MissingFieldVal == True:
                            self.error_msgIndex("Please run the IMAR module first !")
                            break

                        
                        self.controlImar(layers_shp[i],pointLayer_shp[selectedPointLayerIndex],layers_shp[selectedControlLayerIndex],parameters)
            self.success_msg()
                    
          
           
                
                
            
